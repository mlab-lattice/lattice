# Custom Resources

## Extending kubernetes
There are two main ways to extend Kubernetes:
- [Custom Resources](https://kubernetes.io/docs/concepts/api-extension/custom-resources/)
- [API aggregation](https://kubernetes.io/docs/concepts/api-extension/apiserver-aggregation/)

## Custom resources
Custom resources allow you to inject new APIs and resources directly into the kubernetes API.

For example, I could create a new api group called `foo.acme.com`, and `v1` of this API could contain a resource `bar`.

You could then use `kubectl` to manage these resources. For example, `kubectl get --all-namespaces bar.foo.acme.com` would list all of the `bar` resources in the cluster.

## API aggregation
Kubernetes also allows you to write your own api server which it will proxy to when a request comes in for your extension.

For example, when `kubectl get --all-namespaces bar.foo.acme.com` is run, the kubernetes apiserver would proxy the request to the api server that you have provided.

This has the benefit of being able to have multiple versions of an api exposed for the same resource. For example, you could have versions `v1beta1` and `v1` of the `foo.acme.com` group share the same etcd backed data, but return different representations of it.

The drawback of this is that you have to write the api server, compared to custom resources which are handled by the kubernetes apiserver for you.

## Lattice kubernetes extension
Currently, lattice uses custom resources for its extension of kubernetes.

As of writing this, there is one api group `lattice.mlab.com`, and one version `v1`. The different resources in this api can be found at [pkg/backend/kubernetes/customresource/apis/lattice/v1](../../../pkg/backend/kubernetes/customresource/apis/lattice/v1).

These custom resource definitions are added to the kubernetes api during the lattice bootstrap phase.

### Client generation
A nice feature of the kubernetes custom resource ecosystem is the ability to essentially generate a duplicate of [client-go](https://godoc.org/k8s.io/client-go) for your custom resources.

The client can be generated by running:

```bash
make kubernetes.regenerate-custom-resource-clients VERSION=${KUBERNETES_VERSION}
```

This will generate clients, informers, and listers for the custom resources and put them in [pkg/backend/kubernetes/customresource/generated](../../../pkg/backend/kubernetes/customresource/generated).

The client is very simlar to that of `client-go`.

For example, in order to list all the `Deployment`s in the `foo` namespace, you would write:

```go
kubeClient.AppsV1().Deployments("foo").List(options)
```

To list all of the `Builds` in the `foo` namespace, you can write:

```go
latticeClient.LatticeV1().Builds("foo").List(options)
```
