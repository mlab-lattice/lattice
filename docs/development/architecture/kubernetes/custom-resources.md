# Custom Resources

## Extending kubernetes
There are two main ways to extend Kubernetes:
- [Custom Resources](https://kubernetes.io/docs/concepts/api-extension/custom-resources/)
- [API aggregation](https://kubernetes.io/docs/concepts/api-extension/apiserver-aggregation/)

## Custom resources
Custom resources allow you to inject new APIs and resources directly into the kubernetes API.

For example, I could create a new api group called `foo.acme.com`, and `v1` of this API could contain a resource `bar`.

You could then use `kubectl` to manage these resources. For example, `kubectl get --all-namespaces bar.foo.acme.com` would list all of the `bar` resources in the cluster.

## API aggregation
Kubernetes also allows you to write your own api server which it will proxy to when a request comes in for your extension.

For example, when `kubectl get --all-namespaces bar.foo.acme.com` is run, the kubernetes apiserver would proxy the request to the api server that you have provided.

This has the benefit of being able to have multiple versions of an api exposed for the same resource. For example, you could have versions `v1beta1` and `v1` of the `foo.acme.com` group share the same etcd backed data, but return different representations of it.

The drawback of this is that you have to write the api server, compared to custom resources which are handled by the kubernetes apiserver for you.

## Lattice kubernetes extension
Currently, lattice uses custom resources for its extension of kubernetes.

As of writing this, there is one api group `lattice.mlab.com`, and one version `v1`. The different resources in this api can be found at [pkg/backend/kubernetes/customresource/apis/lattice/v1](../../../../pkg/backend/kubernetes/customresource/apis/lattice/v1).

These custom resource definitions are added to the kubernetes api during the lattice bootstrap phase.

### Client generation
A nice feature of the kubernetes custom resource ecosystem is the ability to essentially generate a duplicate of [client-go](https://godoc.org/k8s.io/client-go) for your custom resources.

The client can be generated by running:

```bash
make kubernetes.regenerate-custom-resource-clients VERSION=${KUBERNETES_VERSION}
```

This will generate clients, informers, and listers for the custom resources and put them in [pkg/backend/kubernetes/customresource/generated](../../../../pkg/backend/kubernetes/customresource/generated).

The client is very simlar to that of `client-go`.

For example, in order to list all the `Deployment`s in the `foo` namespace, you would write:

```go
kubeClient.AppsV1().Deployments("foo").List(options)
```

To list all of the `Builds` in the `foo` namespace, you can write:

```go
latticeClient.LatticeV1().Builds("foo").List(options)
```

### Restrictions

Please first read the [documentation](kube-api.md) on the Kubernetes API.

When using the Kubernetes API as an object store, a few restrictions come up.

#### Field uniqueness

The only uniqueness guarantee that is offered is that no two objects of the same `kind` in the same `namespace` will have the same `name`.

As such, if your objects require some uniqueness, you have two options:

1. Name the object the unique name
2. Acquire a global lock on the resource type and ensure that there are no other objects that contain the unique field.
    1. This usually means putting this logic into a controller that is globally responsible for that object type. Read more about controllers in their [documentation](controllers.md).
    2. Usually it can help to use a label for the field you are looking for so you can select objects by the label. This however will often bring up the [restriction on label value length](#label-value-length-limit).
    3. You cannot rely on a cached set of objects when checking for uniqueness. You must check all of the objects from the API. Often it can be helpful to do technique similar to two-phase locking, where you check your cache for an offending object, and only if one is not found, query the API.
 
#### Label value length limit

It's often useful to use [`labels`](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) to attach information to API objects. `Labels` can be useful compared to `annotations` as you can query for objects that have `labels` set to particular values.

However, as mentioned in the [documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set), the value of a `label` `must be 63 characters or less and must be empty or begin and end with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between.`

One workaround for values that you want to be able to query for that do not always conform to this syntax is to hash the desired value and use the hash as the label value.
- note that a hex encoding of a sha256 hash is 64 characters, so you'll have to either use sha1 or a more compact encoding
  - we've typically been using a hex encoding of the sha1 hash. a utility for doing so is available in [`pkg/util/sha1/encode.go`](../../../../pkg/util/sha1/encode.go) (`EncodeToHexString`).
